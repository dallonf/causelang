whitespace_no_newline = _{ " " | "\t" }
whitespace = _{ whitespace_no_newline | NEWLINE }
whitespace_including_newline = _{ whitespace_no_newline* ~ (NEWLINE) ~ whitespace* }
COMMENT = _{ "//" ~ (!NEWLINE ~ ANY)* }


identifier = @{ identifier_first_grapheme ~ identifier_grapheme* }
  identifier_first_grapheme = @{ LETTER | SYMBOL }
  identifier_grapheme = @{ identifier_first_grapheme | MARK | NUMBER }

type_reference = { identifier }

file = { SOI ~ whitespace* ~ (declaration ~ whitespace*)* ~ EOI }

declaration = _{ import_declaration | function_declaration | named_value_declaration }

path_segment = _{ ASCII_ALPHANUMERIC+ }
import_declaration = { "import" ~ whitespace+ ~ import_path ~ whitespace* ~ "{" ~ whitespace* ~ import_mappings? ~ whitespace* ~ "}" }
  import_path = @{ path_segment ~ ("/" ~ path_segment)* }
  import_mappings = _{ import_mapping ~ whitespace* ~ ("," ~ whitespace* ~ import_mapping ~ whitespace*)* ~ whitespace* ~ ","? }
  import_mapping = { identifier ~ ( whitespace+ ~ "as" ~ whitespace+ ~ identifier)? }


function_declaration = { "fn" ~ whitespace+ ~ identifier ~ whitespace* ~ "()" ~ whitespace* ~ structure_body }

named_value_declaration = { "let" ~ whitespace+ ~ identifier ~ whitespace* ~ (":" ~ whitespace* ~ type_reference ~ whitespace*)? ~ "=" ~ whitespace* ~ expression }

structure_body = _{ block_body }

block_body = { "{" ~ whitespace* ~ (statement ~ (whitespace_including_newline ~ statement)*)? ~ whitespace* ~ "}" }

statement = _{ declaration_statement | expression_statement }

expression_statement = { expression }

declaration_statement = { declaration }

expression = {
  (
      string_literal_expression
    | integer_literal_expression
    | cause_expression
    | identifier_expression
  )
  ~ whitespace_no_newline?
  ~ expression_suffix?
}

string_literal_expression = { "\"" ~ string_literal_expression_inner ~ "\"" }
  string_literal_expression_inner = @{ (!"\"" ~ ANY)* }

integer_literal_expression = @{ ASCII_DIGIT ~ (ASCII_DIGIT ~ "_"?)* }

cause_expression = ${ "cause" ~ whitespace+ ~ expression }

identifier_expression = { identifier }

expression_suffix = _{ call_expression_suffix }

call_expression_suffix = { "(" ~ whitespace* ~ (argument ~ whitespace* ~ ("," ~ whitespace* ~ argument ~ whitespace*)*)? ~ ")" }
  argument = _{ named_argument | positional_argument }
  named_argument = { identifier ~ whitespace* ~ "=" ~ whitespace* ~ expression }
  positional_argument = { expression }
