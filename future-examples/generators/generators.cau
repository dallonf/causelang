// This should probably be baked right into the language.
// But I want to exercise the semantics of Effects and make sure
// they're capable of implementing features like generators
// That's how I'll know the model is robust enough to do everything I need

signal YieldIncrement(amountSoFar: Int): Option<Int>
signal Forbidden(): String

// This is a "generator" function
// The return/causes type descriptor should probably be inferred
fn incrementor(): Int causes YieldIncrement, Forbidden {
  let var i = 0
  loop {
    let amountToAdd = cause YieldIncrement(i)
    if match Some(let amountToAdd) as amountToAdd {
      if (amountToAdd->equals(13)) {
        if cause Forbidden()->equals("I'm sorry")->not() {
          // Panic is an optional effect; it doesn't have to be explicitly handled
          cause Panic("Failure to apologize")
        }
      } else {
        i = ->add(amountToAdd)
      }
    } else {
      return i
    }
  }
}

fn callGenerator() {
  // `task incrementor()` executes up to the first cause.
  // it is a mutable value, so it has all the same restrictions as a `var`,
  // and also, if you pass it to any function, the value is consumed
  // and can no longer be used in this scope
  // (perhaps some functions can "borrow" it like in Rust and avoid consuming it)
  loop(task incrementor(), fn(myTask) {
    // next() also consumes the value (`fn Task.next(this: Task<T>)`)
    // It returns a TaskResponse
    branch myTask.next() { 
      let t: TaskEffect<YieldIncrement> => {
        // Any members of a mutable object (such as `t.effect` here) are copied when referenced
        cause Print("Counted to ${t.effect} so far")
        // give() consumes the mutable TaskEffect
        // and returns a Task, which lets you loop back over it
        t.give(Some(1))
      }
      let t: TaskEffect<Forbidden> => {
        t.give("I'm sorry")
      }
      let t: TaskReturn<Int> => {
        // TaskReturn is actually not mutable!
        // It can be passed around freely
        cause Print("Final value: ${t.value}")
        cause LoopBreak(t)
      }
    }
  })
}