// This should probably be baked right into the language.
// But I want to exercise the semantics of Effects and make sure
// they're capable of implementing features like generators
// That's how I'll know the model is robust enough to do everything I need

signal YieldIncrement(amount_so_far: Count): Option<Count>
signal Forbidden(): String

// This is a "generator" function
// The return/causes type descriptor would normally be inferred, but
// it can be explicit to aid reading
fn incrementor(): Count causes YieldIncrement, Forbidden {
	let variables i = 0
	loop {
		let amount_to_add = cause YieldIncrement(i)
		check (amount_to_add: Not<Nothing>) {
			if amount_to_add->equals(13) {
				if not((cause Forbidden())->equals("I'm sorry")) {
					// AssumptionBroken is an optional signal; it doesn't need an explicit effect
					cause AssumptionBroken("Failure to apologize")
				}
			}
		} else {
			return i
		}
	}
}

// Tasks have to be handled by the VM

fn call_generator() causes StartTask, TaskContinue {
	let my_task = cause StartTask(incrementor)

	loop {
		branch with my_task.next() {
			matches task_signal: TaskSignal<YieldIncrement> {
				cause Print("Counted to ${t.effect} so far")
				task_signal.resolve_with(1)
			}
			matches let task_signal: TaskSignal<Forbidden> => task_signal.resolve_with("I'm sorry")
			matches let result: TaskReturn<Count> => {
				cause Print("Final value: ${t.value}")
				return
			}
		}
	}
}
