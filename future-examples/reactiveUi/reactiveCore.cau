protected type ObservableTag<T>(protected tag: Tag)
protected type SubscriptionTag<T>(protected tag: Tag, observableTag: ObservableTag<T>)

protected effect NewObservable<T>(initial: T): ObservableTag<T>

type Subscriber<T> = fn(new: T, previous: T): Action
effect Subscribe<T>(observableTag: ObservableTag<T>, subscriber: Subscriber<T>): Object(
    currentValue: T,
    subscription: SubscriptionTag<T>,
)
effect Unsubscribe<T>(subscription: SubscriptionTag<T>): Action

effect Get<T>(value: supports ObservableTag<T>): T
protected effect SetObservableValue<T>(value: ObservableTag<T>, newValue: Variant(T, Setter<T>)): Action

protected type Observable<T>(
    currentValue: T,
    subscribers: TagMap<Subscriber<T>>,
)

interface ToObservableTag<T> {
    fn toObservableTag(this): T
}

support ToObservableTag<T> on ObservableTag<T> {
    fn toObservableTag(this) => this
}

handler ReactiveHandler {
    let var observables = TagMap<Observable<Dynamic>>()

    handle(
        NewObservable(initial) => {
            let tag = cause NewTag()
            observables = .add(tag, Observable(initial, List()))
            ObservableTag(tag)
        }
        Subscribe(observableTag, subscriber) => {
            let subscriptionTag = cause NewTag()
            observables = .set(observableTag.tag, fn(value) {
                Observable(
                    params(value),
                    subscribers = fn($) $.add(subscriptionTag, subscriber)),
                )
            })
            SubscriptionTag(subscriptionTag, observableTag)
        }
        Unsubscribe(subscriptionTag) => {
            observables = .set(subscriptionTag.observableTag, fn(value) {
                Observable(
                    params(value),
                    subscribers = fn($) $.remove(subscriptionTag),
                )
            })
        }

        Get<T>($) => {
            let observableTag = $.toObservableTag()
            branch observables.get(observableTag.tag) {
                Exists(let value: Observable<T>) => value.currentValue
                default => cause Panic("matching value not found for tag")
            }
        }
        SetObservableValue<T>(observableTag, newValue) => {
            branch observables.get(observableTag.tag) {
                Exists(let value: Observable<T>) => {
                    let oldValue = value.currentValue
                    observables = .set(observableTag.tag, fn($) Observable(
                        params($),
                        currentValue: newValue,
                    ))
                    value.subscribers.each(fn(Pair(_, let $)) {
                        $(oldValue, newValue)
                    })
                }
                default => cause Panic("matching value not found for tag")
            }
        }
    )

    handle(ValueHandler)
}

protected type Value<T>(protected tag: ObservableTag<T>)

support ToObservableTag<T> on Value<T> {
    fn toObservableTag(this) => this.tag
}

effect NewValue<T>(initial: T): Value<T>
effect SetValue<T>(value: Value<T>, newValue: Variant(T, Setter<T>)): Action

handle ValueHandler => handle {
    NewValue(initial) => {
        let observableTag = cause NewObservable(initial)
        Value(observableTag)
    }
    SetValue(value, newValue) => cause SetObservableValue(value.toObservableTag(), newValue)
}
