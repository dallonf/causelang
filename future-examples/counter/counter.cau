fn main() {
  let result = loop(0, fn(counter) {
    cause Print("current value: "->append(toString(cause ReadCounter())))
    cause Print("Type up/down/quit:")
    let input = (cause Prompt())->toLowerCase()
    branch {
      if input->equals("up") => counter->add(1)
      if input->equals("down") => counter->add(-1)
      if input->equals("quit") => cause BreakLoop(counter)
      else {
        cause Print("invalid input: "->append(input))
        counter
      }
    }
  }
  cause Print("Counter quit with value: "->append(result))
}

//probably part of the standard library
signal BreakLoop<T>(value: T): Never

fn loop<T>(startValue: T, loopFn: fn(value: T): T): T  {
  {
    fn innerLoop(value: T) innerLoop(loopFn(value))
    innerLoop(startValue)
  } effect BreakLoop(let value) {
    break value
  }
}
